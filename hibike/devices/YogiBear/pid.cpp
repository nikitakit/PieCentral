#include <PID_v1.h>
#include <FlexiTimer2.h>

#include "pid.h"
float PIDPos = 0;
float PIDPosKP = 0;
float PIDPosKI = 0;
float PIDPosKD = 0;

float PIDVel = 0;
float PIDVelKP = 0;
float PIDVelKI = 0;
float PIDVelKD = 0;

float pwmPID = 0; //Value that is generated by PID, if PID is disabled, this will be equal to pwmInput

PID positionControl(&pos, (double*) &pwmPID, (double*) &PIDPos, (double) PIDPosKP, (double) PIDPosKI, (double) PIDPosKD, DIRECT);
PID velocityControl(&vel, (double*) &pwmPID, (double*) &PIDVel, (double) PIDVelKP, (double) PIDVelKI, (double) PIDVelKD, DIRECT);

void PIDSetup() {
  positionControl.SetOutputLimits(-1, 1);
  positionControl.SetSampleTime(20);
  velocityControl.SetOutputLimits(-1, 1);
  velocityControl.SetSampleTime(20);

  FlexiTimer2::set(20, timerTwoOps); // call every 20ms.  Beware, the API has other, more complicated, ways to set it up.
  FlexiTimer2::start();
}

void timerTwoOps() {
  //updatePos(); //need to make sure that encoder value is updated to the pos variable.
 if (driveMode == 2) {
  posPID();
 } 
 else if (driveMode == 1) {
  velPID();
 }
}

void enablePos() {
  positionControl.SetMode(AUTOMATIC);
  velocityControl.SetMode(MANUAL);
}

void enableVel() {
  positionControl.SetMode(MANUAL);
  velocityControl.SetMode(AUTOMATIC);
}

void disablePID() {
  positionControl.SetMode(MANUAL);
  velocityControl.SetMode(MANUAL);
}

void updatePosPID() {
  positionControl.SetTunings(PIDPosKP, PIDPosKI, PIDPosKD);
}

void updateVelPID() {
  velocityControl.SetTunings(PIDVelKP, PIDVelKI, PIDVelKD);
}

void posPID() {
  positionControl.Compute();
}

void velPID() {
  velocityControl.Compute();
}

void setPosSetpoint(float x) {
  PIDPos = x;
}

void setPosKP(float x) {
  PIDPosKP = x;

}

void setPosKI(float x) {
  PIDPosKI = x;

}

void setPosKD(float x) {
  PIDPosKD = x;
}

void setVelSetpoint(float x) {
  PIDVel = x;

}

void setVelKP(float x) {
  PIDVelKP = x;
}

void setVelKI(float x) {
  PIDVelKI = x;
}

void setVelKD(float x) {
  PIDVelKD = x;
}